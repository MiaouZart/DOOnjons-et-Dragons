@startuml
skinparam linetype ortho


package entity
    {
        abstract class Entity {
           -Sprite: String
           -initiative: int
           -strength: int
           -hp: int
           -dice: Dice
           -maxHp: int
           -armorPoint: int
           -dex: int
           -type: EnumEntity
           -dead: boolean
           -rangePoint: int
           -speed: int
            + Entity(int, int, int, int, int):
            + Entity(int, int, int, int):
            + takeDamage(int)
            + damage(): int
            + getAttacked(Entity): boolean
            + addInitiative(int)
            + say(StandardOut)
            + takeHeal(int)
            + attackBonus(): int



        }

        enum EnumEntity <<enumeration>> {
          PERSONNAGE
          MONSTER
        }
         package monster {
             class Monster extends entity.Entity {
                 - m_specie : String
                 - m_id : Integer
                 - m_atkRange : Integer
                 - m_atkDamage : Dice
                 - m_armor : Integer

                 + <<create>> Monster(HP: Integer, Strength: Integer, Dex: Integer, Speed: Integer, species: String, id: Integer, atkRange: Integer, armor: Integer, dice: Dice)
                 + toString() : String
                 + getRangePoint() : Integer
                 + getArmorPoint() : Integer
                 + damage() : Integer
             }
         }

        package personnage {
            class Personnage extends entity.Entity {
                - m_name : String
                - m_race : Race
                - m_charClass : CharClass
                - m_inventory : Equipment[]
                - m_weapon : Weapon
                - m_armor : Armor
                + <<create>> Personnage(name: String, race: Race, charClass: CharClass)
                + equip(equipment: Equipment)
                + equip(weapon: Weapon)
                + equip(armor: Armor)
                + take(equipment: Equipment)
                + getInventoryString() : String
                + getRangePoint() : Integer
                + getArmorPoint() : Integer
                + getSpells() : Spell[]
                + damage() : Integer
                + attackBonus() : Integer
                + getSpeed() : Integer
                + getStrength() : Integer
                + toString() : String
                + getCharClass() : CharClass
                + getInventory() : Equipment[]
                + getWeapon() : Weapon
                + getArmor() : Armor
        }

        package charclass {
            abstract Class CharClass{
                -baseHealth:Integer
                -name:String
                -baseStuff:Equipment
                -spells:Spell[]
                +<<create>>CharClass(name:String, baseHealth:Integer, baseStuff:Equipment[])
                +<<create>>CharClass(name:String, baseHealth:Integer, baseStuff:Equipment[], spells:Spell[])
                + toString(): String
                + hashCode(): Integer
                + getBaseHealth(): Integer
                + getBaseStuff(): Equipment
                + getSpells(): Spell[]
                + equals(Object): boolean
            }

            package types {
                Class Clerc extends entity.personnage.charclass.CharClass {
                    +<<create>>Clerc()
                }
                Class Warrior extends entity.personnage.charclass.CharClass{
                    +<<create>>Warrior()
                }
                Class Wizard extends entity.personnage.charclass.CharClass{
                   +<<create>>Wizard()
                }
                Class Rogue extends entity.personnage.charclass.CharClass{
                   +<<create>>Rogue()
                }
            }
        }

        package race{
            abstract class Race{
                  initiative: int
                  strength: int
                  dex: int
                  speed: int
                 + Race(String, int, int, int, int):
                 + hashCode(): int
                 + toString(): String
                 + equals(Object): boolean
            }
            package types{
                Class Human extends entity.personnage.race.Race{
                    -{static}defaultSpeed:Integer
                    -{static}defaultDex:Integer
                    -{static}defaultStrength:Integer
                    -{static}defaultInitiative:Integer
                    +<<create>>Human()
                }
                Class Dwarf extends entity.personnage.race.Race{
                    -{static}defaultSpeed:Integer
                    -{static}defaultDex:Integer
                    -{static}defaultStrength:Integer
                    -{static}defaultInitiative:Integer
                    +<<create>>Dwarf()
                }
                Class Elf extends entity.personnage.race.Race{
                    -{static}defaultSpeed:Integer
                    -{static}defaultDex:Integer
                    -{static}defaultStrength:Integer
                    -{static}defaultInitiative:Integer
                    +<<create>>Elf()
                }
                Class Halfelin extends entity.personnage.race.Race{
                    -{static}defaultSpeed:Integer
                    -{static}defaultDex:Integer
                    -{static}defaultStrength:Integer
                    -{static}defaultInitiative:Integer
                    +<<create>>Halfelin()
                }
            }
        }

    }
}

package equipment {
    Abstract class Equipment{
        -name: String
        -type: EquipmentType
        +<<create>>Equipment(name:String, type:EquipmentType);
        +getName() : String
        +getEquipmentType() : EquipmentType
    }

    enum EquipmentType <<enumeration>> {
        ARMOR
        WEAPON
    }

    package armor {
        Abstract Armor Extends equipment.Equipment{
            +<<create>> Armor(name:String,classVal:Integer,speedModifier:Integer)
            + equals(Object): boolean
            + hashCode(): Integer
            -classVal : Integer
            -speedModifier : Integer
            -name : String
        }

        Abstract Heavy Extends Armor {
            +<<create>> Heavy(name:String, classVal:Integer)
        }

        Abstract Light Extends Armor {
            +<<create>> Light(name:String, classVal:Integer)
        }

        package types {
            Class ScaleMail Extends equipment.armor.Light {
                + <<create>>ScaleMail()
            }

            Class HalfPlate Extends equipment.armor.Light {
                + <<create>>HalfPlate()
            }

            Class ChainMail Extends equipment.armor.Heavy {
                + <<create>>ChainMail()
            }

            Class Plate Extends equipment.armor.Heavy {
                + <<create>>Plate()
            }
        }
    }

    package weapon {
        Abstract class Weapon Extends equipment.Equipment {
            -range : Integer
            -speedModifier : Integer
            -strengthModifier : Integer
            -name:String
            -damageDice:Dice
            - bonusAtk:Integer
            - bonusDam:Integer
            +<<create>>Weapon(name:String,range:Integer,damage:Dice,speedModifier:Integer,strengthModifier:Integer);
            + hashCode(): int
            + equals(Object): booleanInteger
            + damage() : Integer
            + addBonusAttack(bonus:Integer)
            + addBonusDamage(bonus:Integer)
            + getBonusAttack() : Integer
            + getBonusDamage() : Integer
        }

        Abstract Simple extends Weapon {
            +<<create>>Simple(name:String, range:Integer, damage:Dice)
        }

        Abstract Martial extends Weapon {
            +<<create>>Martial(name:String, range:Integer, damage:Dice)
        }

        Abstract Ranged extends Weapon {
            +<<create>>Ranged(name:String, range:Integer, damage:Dice)
        }

        package types {

            class Quarterstaff extends equipment.weapon.Simple {
                +<<create>> Quarterstaff()
            }

            class Mace extends equipment.weapon.Simple {
                +<<create>> Mace()
            }

            class Longsword extends equipment.weapon.Martial {
                +<<create>> Longsword()
            }

            class Greatsword extends equipment.weapon.Martial {
                +<<create>> Greatsword()
            }

            class Rapier extends equipment.weapon.Martial {
                +<<create>> Rapier()
            }

            class Crossbow extends equipment.weapon.Ranged {
                +<<create>> Crossbow()
            }

            class Sling extends equipment.weapon.Ranged {
                +<<create>> Sling()
            }

            class Shortbow extends equipment.weapon.Ranged {
                +<<create>> Shortbow()
            }
        }
    }

}

package dice{
    Class Dice{
        -value:Integer
        -nbRoll:Integer
        +<<create>>Dice(throw:Integer,value:Integer)
        + hashCode(): Integer
        + toString(): String
        + roll(): Integer[]
        + equals(Object): boolean
    }
}

package donjon{
        class Donjon{
            -donjonGrid: String[][]
            -win: boolean
            -turn: int
            -entities: HashMap<Entity, int[]>
            -loose: boolean
            -donjonSize: int
            + Donjon(int, HashMap<Entity, int[]>):
            - entityPosition()
            + playerAttack(Entity)
            + nextTurn()
            - initiativeInit()
            - distance(Entity, Entity): int
            - checkWin()
            - initializeGrid()
            + moveEntity(Entity)
            + setupDonjon()
            + createObstacle()
            + entityPosition(Entity)
            - promptContext()

    }

    class CharacterCreator {
        + CharacterCreator()
        - {static}promptRace(Scanner): Race
        - {static}promptClass(Scanner): CharClass
        # {static}create(): Personnage
        - {static}promptName(Scanner): String
    }

    class Display {
         - output: StandardOut
        + Display(Donjon, StandardOut)
        # retrieveGridPosition(String): int[]
        # checkEmptyCaseNonVerbose(int, int, String[][], int): boolean
        + promptInt(String, int, int): int
        + refreshDisplay()
        # retrieveInt(String): int
        + init(StandardOut)
        # checkEmptyCase(int, int, String[][], int): boolean
        + promptInt(String): int
        + promptChoice(ArrayList<String>, boolean): int
        # displayTitle(String)
        # displayGrid()
        # displayTurn()


    }
    class EquipmentCreator {
        + EquipmentCreator()
        + create(Display, String[][], HashMap<int[], Equipment>)
        - positionEquipment(Display, Equipment, String[][], HashMap<int[], Equipment>
        - createEquipment(Display): Equipment
        - createArmor(Display): Equipment
        - createWeapon(Display): Equipment
    }
    class MonsterCreator {
      + MonsterCreator():
      # bulkCreate(Display, String[][], HashMap<Entity, int[]>): int
      # promptPosition(Display, String[][]): int[]
      # createMonster(String, Display): Monster
    }
    class ObstacleCreator {
      + ObstacleCreator():
      + bulkCreate(Display, String[][])
      - create(String, String[][])
    }
    class Game {
      + Game():
      - getAvailableActions(Entity, ArrayList<String>, Weapon): ArrayList<String>
      + commenter(Entity)
      - displayEntityInfo(Entity, int, Armor, Weapon, Equipment[], int, int, int, int)
      - handleEquipment(Entity, Equipment[])
      - retrievePlayerOrder()
      - entityTurn(Entity)
      - handleSpell(Personnage)
      - setUp()
      - game()
      - handleAction(String, Entity, Equipment[])
    }

    class GameMaster{
          +GameMaster(entityHashMapCopy :[Entity;Integer[2]]
          +say(phrase:String)
          +gameMasterTurn()
          +displayPlayer()
          +changeEntityPos()
          +inflictDamage()
          +addObstacle()
    }
    package defaultDonjon{
        abstract class Default {
            #entities: HashMap<Entity, Integer[]>
            #donjon: Donjon

            #<<create>> Default(entities:HashMap<Entity, Integer[]>, size:Integer)
            #initialiseWalls(donjon:Donjon):String[][]
            - {static} setupDefaultDonjon()
            - {abstract} initializeDefaultGrid()
            - {abstract} createDefaultPlayers()
            - {abstract} createDefaultMonsters()
            + getDonjon(): Donjon
        }
        class Default1 extends Default {
            + Default1(entities: HashMap<Entity, Integer[]>)
            # initializeDefaultGrid()
            # createDefaultPlayers()
            # createDefaultMonsters()
        }
        class Default2 extends Default {
            + Default2(entities: HashMap<Entity, Integer[]>)
            # initializeDefaultGrid()
            # createDefaultPlayers()
            # createDefaultMonsters()
        }
        class Default3 extends Default {
            + Default3(entities: HashMap<Entity, Integer[]>)
            # initializeDefaultGrid()
            # createDefaultPlayers()
            # createDefaultMonsters()
        }
    }
}

package spell {
    package type {
        class BoogieWoogie extends spell.Spell {
            + <<create>> BoogieWoogie()
            + spell(entities:HashMap<Entity, int[]>)
        }
        class Heal extends spell.Spell {
            + <<create>> Heal()
            + spell(entities:HashMap<Entity, int[]>)
        }
        class MagicWeapon extends spell.Spell {
            + <<create>> MagicWeapon()
            + spell(entities:HashMap<Entity, int[]>)
        }
    }

    class Spell {
        + Spell(String):
        + toString(): String
        + equals(Object): boolean
        + spell(HashMap<Entity, int[]>, String[][])
        + hashCode(): int

    }
}


package printer{
    class StandardOut {
      + StandardOut():
      + out(String)
      + in(): String
      + outLn(String)
      + printf(String, int, String)
      + printf(String, Object)
    }
    class SystemOut extends StandardOut {
      + SystemOut():
      + printf(String, int, String)
      + outLn(String)
      + in(): String
      + out(String)
      + printf(String, Object)
    }
}


class Main {
    +{static}<<create>>Main(args:String[])
    game:Game
}

Main "1" *-->"game" Game : <<use>>

Armor             -->  EquipmentType
BoogieWoogie      -->  Display
BoogieWoogie      -->  Entity
CharClass        "1" *--> "m_baseStuff\n*" Equipment
CharClass        "1" *--> "m_spells\n*" Spell
CharClass         -->  Spell            : "«use»"
CharacterCreator  -->  CharClass        : "«create»"
CharacterCreator  -->  Display          : "«use»"
CharacterCreator "1" *--> "m_output\n1" StandardOut
CharacterCreator  -->  Warrior          : "«create»"
CharacterCreator  -->  Wizard           : "«create»"
Crossbow          -->  Dice             : "«create»"
Default           -->  Donjon           : "«create»"
Default          "1" *--> "m_donjon\n1" Donjon
Default          "1" *--> "m_entities\n*" Entity
Default1          -->  Donjon   : "«create»"
Default2          -->  Donjon   : "«create»"
Default3          -->  Donjon   : "«create»"
Display          "1" *--> "m_donjon\n1" Donjon
Display          "1" *--> "m_output\n1" StandardOut
Donjon            -->  Dice             : "«create»"
Donjon            -->  Display          : "«create»"
Donjon           "1" *--> "m_display\n1" Display
Donjon           "1" *--> "m_entities\n*" Entity
Donjon            -->  EnumEntity
Donjon           "1" *--> "m_equipments\n*" Equipment
Donjon            -->  EquipmentCreator
Donjon            -->  MonsterCreator
Donjon            -->  ObstacleCreator
Donjon            -->  Personnage
Donjon            -->  StandardOut
Donjon            -->  SystemOut        : "«create»"
Entity            -->  Dice             : "«create»"
Entity           "1" *--> "m_type\n1" EnumEntity
Entity            -->  StandardOut
Equipment        "1" *--> "m_type\n1" EquipmentType
EquipmentCreator  -->  Display  : "«use»"
EquipmentCreator  -->  Equipment: "«create»"
EquipmentCreator  -->  StandardOut  : "«use»"
Game              -->  Default : "«create»"
Game              -->  Display : "«create»"
Game              -->  Donjon           : "«create»"
Game             "1" *--> "m_donjon\n1" Donjon
Game             "1" *--> "m_entities\n*" Entity
Game              -->  EnumEntity : "«use»"
Game              -->  Equipment : "«use»"
Game             "1" *--> "m_gameMaster\n1" GameMaster
Game              -->  GameMaster       : "«create»"
Game              -->  Personnage : "«use»"
Game              -->  Spell: "«use»"
Game             "1" *--> "m_output\n1" StandardOut
Game              -->  SystemOut        : "«use»"
GameMaster        -->  Dice             : "«use»"
GameMaster        -->  Display
GameMaster       "1" *--> "m_donjon\n1" Donjon
GameMaster       "1" *--> "m_entityHashMapCopy\n*" Entity
GameMaster       "1" *--> "m_output\n1" StandardOut
Monster          "1" *--> "m_atkDamage\n1" Dice
Monster           -->  EnumEntity : "«use»"
MonsterCreator    -->  Display : "«use»"
MonsterCreator    -->  Monster          : "«create»"
MonsterCreator    -->  StandardOut : "«use»"
ObstacleCreator   -->  Display : "«use»"
ObstacleCreator   -->  StandardOut : "«use»"
Personnage       "1" *--> "m_armor\n1" Armor
Personnage       "1" *--> "m_charClass\n1" CharClass
Personnage        -->  Dice             : "«use»"
Personnage        -->  EnumEntity : "«use»"
Personnage       "1" *--> "m_inventory\n*" Equipment
Personnage        -->  EquipmentType : "«use»"
Personnage       "1" *--> "m_race\n1" Race
Personnage        -->  Spell : "«use»"
Personnage       "1" *--> "m_weapon\n1" Weapon
Weapon           "1" *--> "m_damageDice\n1" Dice
Weapon           "1" *--> "m_type\n1" EnumWeaponType
@enduml